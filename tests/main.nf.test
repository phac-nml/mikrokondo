nextflow_pipeline {

    name "Full Integration Tests for MIKROKONDO"
    script "main.nf"

    test("Should fail to assembly due to too few reads.") {
        tag "fail_assembly"

        when {
            params {
                input = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/samplesheets/samplesheet-campy-staph.csv"
                outdir = "results"

                platform = "illumina"

                mash_sketch = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy-staph-ecoli.msh"
                mh_min_kmer = 1

                dehosting_idx = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy.mmi"

                kraken2_db = "$baseDir/tests/data/kraken2/test"

                min_reads = 100

                skip_bakta = true
                skip_staramr = true
                skip_mobrecon = true
                skip_checkm = true
                skip_raw_read_metrics = true
                skip_polishing = true
                skip_allele_calling = true

                max_memory = "2.GB"
                max_cpus = 1
            }
        }

        then {
            assert workflow.success
            assert path("$launchDir/results").exists()

            // parse output json file
            def json = path("$launchDir/results/FinalReports/Aggregated/Json/final_report.json").json

            assert json.CSE.CSE.FastP.summary.sequencing.equals("paired end (150 cycles + 150 cycles)")
            assert json.CSE.CSE.FastP.summary.before_filtering.total_reads.equals(248)
            assert json.CSE.CSE.FastP.filtering_result.passed_filter_reads.equals(248)
            assert json.CSE.CSE.FastP.insert_size.peak.equals(196)
            assert json.CSE.CSE.FastP.filtering_result.low_quality_reads.equals(0)

            //assert json.CSE.meta.metagenomic.equals(false)  // Currently, this is "null".
            assert json.CSE.meta.assembly.equals(false)
            assert json.CSE.meta.hybrid.equals(false)
            assert json.CSE.meta.single_end.equals(false)
            assert json.CSE.meta.merge.equals(false)
            assert json.CSE.meta.downsampled.equals(false)

            def assembly_path = "$launchDir/results/Assembly/FinalAssembly/CSE/CSE.final.filtered.assembly.fasta.gz"
            assert path(assembly_path).exists().equals(false)

            def contigs_path = "$launchDir/results/Assembly/FinalAssembly"
            assert path(contigs_path).exists().equals(false)

            // compare IRIDA Next JSON output
            def iridanext_json = path("$launchDir/results/iridanext.output.json").json
            def iridanext_global = iridanext_json.files.global
            def iridanext_samples = iridanext_json.files.samples
            def iridanext_metadata = iridanext_json.metadata.samples

            // output files
            assert iridanext_global.findAll { it.path == "FinalReports/Aggregated/Json/final_report.json" }.size() == 1
            assert iridanext_global.findAll { it.path == "FinalReports/Aggregated/Tables/final_report.tsv" }.size() == 1
            assert iridanext_samples.CSE.findAll { it.path.contains("Assembly/FinalAssembly") }.size() == 0
            assert iridanext_samples.CSE.findAll { it.path.contains("Assembly/FinalReports/FlattenedReports/CSE.flat_sample.json.gz") }.size() == 0

            // metadata
            assert iridanext_metadata.CSE.containsKey("QC Status")
            assert iridanext_metadata.CSE."QC Status" == "FAILED"
            assert !iridanext_metadata.CSE.containsKey("Checkm Status")
            assert !iridanext_metadata.CSE.containsKey("Checkm Value")
            assert !iridanext_metadata.CSE.containsKey("Average Coverage Status")
            assert !iridanext_metadata.CSE.containsKey("Average Coverage Value")
            assert !iridanext_metadata.CSE.containsKey("n50 Status")
            assert !iridanext_metadata.CSE.containsKey("n50 Value")
            assert !iridanext_metadata.CSE.containsKey("Raw Average Quality Status")
            assert !iridanext_metadata.CSE.containsKey("Raw Average Quality Value")
            assert !iridanext_metadata.CSE.containsKey("Length Status")
            assert !iridanext_metadata.CSE.containsKey("Length Value")
            assert !iridanext_metadata.CSE.containsKey("nr contigs Status")
            assert !iridanext_metadata.CSE.containsKey("nr contigs Value")
            assert iridanext_metadata.CSE."QC Summary" == "FAILED Species ID: null; Passed Tests: 0/6; Organism QC Criteria: No organism specific QC data available."

            assert iridanext_metadata.CSE."Downsampled" == false
            assert !iridanext_metadata.CSE.containsKey("predicted_identification_name")
            assert !iridanext_metadata.CSE.containsKey("predicted_identification_method")
            assert !iridanext_metadata.CSE.containsKey("GC (%)")
            //assert iridanext_metadata.CSE."Mean Sequence Length Forward" == 150
            // Base count after decontamination
            assert iridanext_metadata.CSE."BaseCount" == 37200
        }
    }

    test("Should run without failure.") {
        tag "succeed_assembly"

        when {
            params {
                input = "https://raw.githubusercontent.com/phac-nml/mikrokondo/dev/tests/data/samplesheets/samplesheet-small-assembly.csv"
                outdir = "results"

                platform = "illumina"

                mash_sketch = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy-staph-ecoli.msh"
                mh_min_kmer = 1

                dehosting_idx = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy.mmi"
                kraken2_db = "$baseDir/tests/data/kraken2/test"

                min_reads = 100

                skip_allele_calling = true

                QCReport {
                    fallthrough {
                        search = "No organism specific QC data available."
                        raw_average_quality = 30
                        min_n50 = null
                        max_n50 = null
                        min_nr_contigs = null
                        max_nr_contigs = null
                        fixed_genome_size = 1000
                        min_length = null
                        max_length = null
                        max_checkm_contamination = 3.0
                        min_average_coverage = 30
                    }
                }


                skip_bakta = true
                skip_staramr = false
                skip_mobrecon = false
                skip_checkm = false
                skip_raw_read_metrics = false
                skip_polishing = false

                max_memory = "2.GB"
                max_cpus = 1
            }
        }

        then {

            assert workflow.success
            assert path("$launchDir/results").exists()

            // parse output json file
            def json = path("$launchDir/results/FinalReports/Aggregated/Json/final_report.json").json

            assert json.short.short.RawReadSummary.R1."total_bp".equals(118750)
            assert json.short.short.RawReadSummary.R1."total_reads".equals(475)
            assert json.short.short.RawReadSummary.R1."read_qual_mean".equals(40.0)
            assert json.short.short.RawReadSummary.R1."mean_sequence_length".equals(250.0)

            assert json.short.short.FastP.summary.sequencing.equals("paired end (250 cycles + 250 cycles)")
            assert json.short.short.FastP.summary.before_filtering.total_reads.equals(950)
            assert json.short.short.FastP.filtering_result.passed_filter_reads.equals(950)
            assert json.short.short.FastP.filtering_result.low_quality_reads.equals(0)
            assert json.short.short.FastP.insert_size.peak.equals(347)

            //assert json.short.meta.metagenomic.equals(false)  // Currently, this is "null".
            assert json.short.meta.assembly.equals(false)
            assert json.short.meta.hybrid.equals(false)
            assert json.short.meta.single_end.equals(false)
            assert json.short.meta.merge.equals(false)
            assert json.short.meta.downsampled.equals(false)

            assert json.short.short.AssemblyCompleted.equals(true)
            assert json.short.short.QUAST."0"."Total length (>= 0 bp)".equals("4949")
            assert json.short.short.QUAST."0"."Largest contig".equals("4949")
            assert json.short.short.QUAST."0"."GC (%)".equals("52.96")
            assert json.short.short.QUAST."0"."Avg. coverage depth".equals("47")

            // Below two values should be empty
            assert json.short.short.StarAMR."0"."Genotype".equals("None")
            assert json.short.short.StarAMR."0"."Predicted Phenotype".equals("Susceptible")
            assert json.short.short.StarAMR."0"."Genome Length".equals("4949")

            assert json.short.short.CheckM."0"."# genomes".equals("5656")
            assert json.short.short.CheckM."0"."# markers".equals("56")
            assert json.short.short.CheckM."0"."# marker sets".equals("24")
            assert json.short.short.CheckM."0".Contamination.equals("0.00")

            assert json.short.short.SevenGeneMLSTReport[0].filename.equals("short.filtered.fasta.gz")

            assert json.short.short.Abricate."0".RESISTANCE.equals("NoData")  // All Abricate results for this are "NoData".

            def assembly_path = "$launchDir/results/Assembly/FinalAssembly/short/short.final.filtered.assembly.fasta.gz"
            assert path(assembly_path).exists()

            // parse assembly file
            def assembly_header = path(assembly_path).linesGzip[0]
            assert assembly_header.startsWith(">NODE_1_length_4949_cov_23.917254")  // _pilon_pilon_pilon gets appended

            // compare IRIDA Next JSON output
            def iridanext_json = path("$launchDir/results/iridanext.output.json").json
            def iridanext_global = iridanext_json.files.global
            def iridanext_samples = iridanext_json.files.samples
            def iridanext_metadata = iridanext_json.metadata.samples

            // output files
            assert iridanext_global.findAll { it.path == "FinalReports/Aggregated/Json/final_report.json" }.size() == 1
            assert iridanext_global.findAll { it.path == "FinalReports/Aggregated/Tables/final_report.tsv" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Assembly/FinalAssembly/short/short.final.filtered.assembly.fasta.gz" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Assembly/Quality/QUAST/short/short.transposed_short.quast.quality.tsv" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Assembly/Quality/SeqKitStats/short.seqkit.stats.summary.tsv" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Assembly/PostProcessing/Speciation/MashScreen/short.mash.screen.taxa.screen.screen" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Reads/Quality/Trimmed/MashScreen/short.mash.screen.reads.screen.screen" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Reads/Quality/Trimmed/FastP/short.fastp.summary.json" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Reads/Quality/RawReadQuality/short.read.scan.summary.json" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "FinalReports/FlattenedReports/short.flat_sample.json.gz" }.size() == 1

            // output metadata
            assert iridanext_metadata.short."QC Status" == "PASSED"
            assert iridanext_metadata.short."Checkm Status" == "PASSED"
            assert iridanext_metadata.short."Checkm Value" == 0.0
            assert iridanext_metadata.short."Average Coverage Status" == "PASSED"
            assert iridanext_metadata.short."Average Coverage Value" == 237.5
            assert iridanext_metadata.short."n50 Status" == "WARNING"
            assert iridanext_metadata.short."n50 Value" == 4949
            assert iridanext_metadata.short."Raw Average Quality Status" == "PASSED"
            assert iridanext_metadata.short."Raw Average Quality Value" == 40.0
            assert iridanext_metadata.short."Length Status" == "WARNING"
            assert iridanext_metadata.short."Length Value" == 4949
            assert iridanext_metadata.short."nr contigs Status" == "WARNING"
            assert iridanext_metadata.short."nr contigs Value" == 1
            assert iridanext_metadata.short."QC Summary" == "PASSED Species ID: No Species Identified; Passed Tests: 6/6; Organism QC Criteria: No organism specific QC data available."

            assert iridanext_metadata.short."Downsampled" == false
            assert iridanext_metadata.short."predicted_identification_name" == "No Species Identified"
            assert iridanext_metadata.short."predicted_identification_method" == "Mash"
            assert iridanext_metadata.short."GC (%)" == "52.96"
            assert iridanext_metadata.short."Mean Sequence Length Forward" == 250
            assert iridanext_metadata.short."BaseCount" == 237500

            assert iridanext_metadata.short."StarAMR Genotype" == "None"
            assert iridanext_metadata.short."StarAMR Predicted Phenotype" == "Susceptible"
        }

    }

    test("Should assemble but fail average coverage check") {
        tag "succeed_assembly_fail_coverage"

        when {
            params {
                input = "https://raw.githubusercontent.com/phac-nml/mikrokondo/dev/tests/data/samplesheets/samplesheet-small-assembly.csv"
                outdir = "results"

                platform = "illumina"

                mash_sketch = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy-staph-ecoli.msh"
                mh_min_kmer = 1

                dehosting_idx = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy.mmi"
                kraken2_db = "$baseDir/tests/data/kraken2/test"

                min_reads = 100

                skip_allele_calling = true

                QCReport {
                    fallthrough {
                        search = "No organism specific QC data available."
                        raw_average_quality = 30
                        min_n50 = null
                        max_n50 = null
                        min_nr_contigs = null
                        max_nr_contigs = null
                        fixed_genome_size = 1000000
                        min_length = null
                        max_length = null
                        max_checkm_contamination = 3.0
                        min_average_coverage = 30
                    }
                }


                skip_bakta = true
                skip_staramr = false
                skip_mobrecon = false
                skip_checkm = false
                skip_raw_read_metrics = false
                skip_polishing = false

                max_memory = "2.GB"
                max_cpus = 1
            }
        }

        then {

            assert workflow.success
            assert path("$launchDir/results").exists()

            // parse output json file
            def json = path("$launchDir/results/FinalReports/Aggregated/Json/final_report.json").json

            assert json.short.short.RawReadSummary.R1."total_bp".equals(118750)
            assert json.short.short.RawReadSummary.R1."total_reads".equals(475)
            assert json.short.short.RawReadSummary.R1."read_qual_mean".equals(40.0)
            assert json.short.short.RawReadSummary.R1."mean_sequence_length".equals(250.0)

            assert json.short.short.FastP.summary.sequencing.equals("paired end (250 cycles + 250 cycles)")
            assert json.short.short.FastP.summary.before_filtering.total_reads.equals(950)
            assert json.short.short.FastP.filtering_result.passed_filter_reads.equals(950)
            assert json.short.short.FastP.filtering_result.low_quality_reads.equals(0)
            assert json.short.short.FastP.insert_size.peak.equals(347)

            //assert json.short.meta.metagenomic.equals(false)  // Currently, this is "null".
            assert json.short.meta.assembly.equals(false)
            assert json.short.meta.hybrid.equals(false)
            assert json.short.meta.single_end.equals(false)
            assert json.short.meta.merge.equals(false)
            assert json.short.meta.downsampled.equals(false)

            assert json.short.short.AssemblyCompleted.equals(true)
            assert json.short.short.QUAST."0"."Total length (>= 0 bp)".equals("4949")
            assert json.short.short.QUAST."0"."Largest contig".equals("4949")
            assert json.short.short.QUAST."0"."GC (%)".equals("52.96")
            assert json.short.short.QUAST."0"."Avg. coverage depth".equals("47")

            // Below two values should be empty
            assert json.short.short.StarAMR."0"."Genotype".equals("None")
            assert json.short.short.StarAMR."0"."Predicted Phenotype".equals("Susceptible")
            assert json.short.short.StarAMR."0"."Genome Length".equals("4949")

            assert json.short.short.CheckM."0"."# genomes".equals("5656")
            assert json.short.short.CheckM."0"."# markers".equals("56")
            assert json.short.short.CheckM."0"."# marker sets".equals("24")
            assert json.short.short.CheckM."0".Contamination.equals("0.00")

            assert json.short.short.SevenGeneMLSTReport[0].filename.equals("short.filtered.fasta.gz")

            assert json.short.short.Abricate."0".RESISTANCE.equals("NoData")  // All Abricate results for this are "NoData".

            def assembly_path = "$launchDir/results/Assembly/FinalAssembly/short/short.final.filtered.assembly.fasta.gz"
            assert path(assembly_path).exists()

            // parse assembly file
            def assembly_header = path(assembly_path).linesGzip[0]
            assert assembly_header.startsWith(">NODE_1_length_4949_cov_23.917254")  // _pilon_pilon_pilon gets appended

            // compare IRIDA Next JSON output
            def iridanext_json = path("$launchDir/results/iridanext.output.json").json
            def iridanext_global = iridanext_json.files.global
            def iridanext_samples = iridanext_json.files.samples
            def iridanext_metadata = iridanext_json.metadata.samples

            // output files
            assert iridanext_global.findAll { it.path == "FinalReports/Aggregated/Json/final_report.json" }.size() == 1
            assert iridanext_global.findAll { it.path == "FinalReports/Aggregated/Tables/final_report.tsv" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Assembly/FinalAssembly/short/short.final.filtered.assembly.fasta.gz" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Assembly/Quality/QUAST/short/short.transposed_short.quast.quality.tsv" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Assembly/Quality/SeqKitStats/short.seqkit.stats.summary.tsv" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Assembly/PostProcessing/Speciation/MashScreen/short.mash.screen.taxa.screen.screen" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Reads/Quality/Trimmed/MashScreen/short.mash.screen.reads.screen.screen" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Reads/Quality/Trimmed/FastP/short.fastp.summary.json" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "Reads/Quality/RawReadQuality/short.read.scan.summary.json" }.size() == 1
            assert iridanext_samples.short.findAll { it.path == "FinalReports/FlattenedReports/short.flat_sample.json.gz" }.size() == 1

            // output metadata
            assert iridanext_metadata.short."QC Status" == "FAILED"
            assert iridanext_metadata.short."Checkm Status" == "PASSED"
            assert iridanext_metadata.short."Checkm Value" == 0.0
            assert iridanext_metadata.short."Average Coverage Status" == "FAILED"
            assert iridanext_metadata.short."Average Coverage Value" == 0.24
            assert iridanext_metadata.short."n50 Status" == "WARNING"
            assert iridanext_metadata.short."n50 Value" == 4949
            assert iridanext_metadata.short."Raw Average Quality Status" == "PASSED"
            assert iridanext_metadata.short."Raw Average Quality Value" == 40.0
            assert iridanext_metadata.short."Length Status" == "WARNING"
            assert iridanext_metadata.short."Length Value" == 4949
            assert iridanext_metadata.short."nr contigs Status" == "WARNING"
            assert iridanext_metadata.short."nr contigs Value" == 1
            assert iridanext_metadata.short."QC Summary" == "FAILED Species ID: No Species Identified; Passed Tests: 5/6; Organism QC Criteria: No organism specific QC data available."

            assert iridanext_metadata.short."Downsampled" == false
            assert iridanext_metadata.short."predicted_identification_name" == "No Species Identified"
            assert iridanext_metadata.short."predicted_identification_method" == "Mash"
            assert iridanext_metadata.short."GC (%)" == "52.96"
            assert iridanext_metadata.short."Mean Sequence Length Forward" == 250
            assert iridanext_metadata.short."BaseCount" == 237500

            assert iridanext_metadata.short."StarAMR Genotype" == "None"
            assert iridanext_metadata.short."StarAMR Predicted Phenotype" == "Susceptible"
        }

    }

    test("Should run without failure metagenomic.") {
        tag "succeed_assembly_meta"

        when {
            params {
                input = "https://raw.githubusercontent.com/phac-nml/mikrokondo/dev/tests/data/samplesheets/samplesheet-small-assembly.csv"
                outdir = "results"

                platform = "illumina"

                mash_sketch = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy-staph-ecoli.msh"
                mh_min_kmer = 1

                dehosting_idx = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy.mmi"
                kraken2_db = "$baseDir/tests/data/kraken2/test"

                metagenomic_run = true
                min_reads = 100

                skip_allele_calling = true


                skip_bakta = true
                skip_staramr = false
                skip_mobrecon = false
                skip_checkm = false
                skip_raw_read_metrics = false
                skip_polishing = false

                max_memory = "2.GB"
                max_cpus = 1
            }
        }

        then {

            assert workflow.success
            assert path("$launchDir/results").exists()
            // parse output json file
            def iridanext_json = path("$launchDir/results/iridanext.output.json").json
            assert iridanext_json.metadata.samples.short."QC Status" == "NA"
            assert iridanext_json.metadata.samples.short."QC Summary" ==  "No quality control criteria is applied for metagenomic samples."

        }
    }

    test("Should run without failure metagenomic viruses.") {
    tag "succeed_assembly_meta_viruses"

        when {
            params {
                input = "$baseDir/tests/data/samplesheets/samplesheet-small-metagenomic.csv"
                outdir = "results"

                platform = "illumina"

                mash_sketch = "$baseDir/tests/data/databases/virus.msh"
                mh_min_kmer = 1

                dehosting_idx = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy.mmi"
                kraken2_db = "$baseDir/tests/data/kraken2/test"
                min_reads = 2
                skip_allele_calling = true
                skip_bakta = true
                skip_staramr = false
                skip_mobrecon = false
                skip_checkm = false
                skip_raw_read_metrics = false
                skip_polishing = false

                max_memory = "2.GB"
                max_cpus = 1
            }
        }

        then {

            assert workflow.success
            assert path("$launchDir/results").exists()
            // parse output json file
            def iridanext_json = path("$launchDir/results/iridanext.output.json").json
            assert iridanext_json.metadata.samples."meta-small"."QC Status" == "FAILED"
            assert iridanext_json.metadata.samples."meta-small"."QC Summary" ==  "[FAILED] Sample was determined to be metagenomic and this was not specified as a metagenomic run indicating contamination.'"

        }
    }

    test("Test validation of platform parameter") {
        tag "fail_validation"

        when {
            params {
                input = "https://raw.githubusercontent.com/phac-nml/mikrokondo/dev/tests/data/samplesheets/samplesheet-small-assembly.csv"
                outdir = "results"

                mash_sketch = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy-staph-ecoli.msh"
                mh_min_kmer = 1

                dehosting_idx = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy.mmi"
                kraken2_db = "$baseDir/tests/data/kraken2/test"

                min_reads = 100

                skip_bakta = true
                skip_staramr = false
                skip_mobrecon = false
                skip_checkm = false
                skip_raw_read_metrics = false
                skip_polishing = false

                max_memory = "2.GB"
                max_cpus = 1

                // parameter to fail validation
                platform = "invalid"
            }
        }

        then {
            assert workflow.failed
            assert workflow.stderr.contains("* --platform: 'invalid' is not a valid choice (Available choices: illumina, nanopore, pacbio, hybrid)")
        }
    }

    test("Test validation of contig minimum length parameter") {
        tag "fail_validation"

        when {
            params {
                input = "https://raw.githubusercontent.com/phac-nml/mikrokondo/dev/tests/data/samplesheets/samplesheet-small-assembly.csv"
                outdir = "results"

                platform = "illumina"

                mash_sketch = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy-staph-ecoli.msh"
                mh_min_kmer = 1

                dehosting_idx = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy.mmi"

                kraken2_db = "$baseDir/tests/data/kraken2/test"

                min_reads = 100

                skip_bakta = true
                skip_staramr = false
                skip_mobrecon = false
                skip_checkm = false
                skip_raw_read_metrics = false
                skip_polishing = false

                max_memory = "2.GB"
                max_cpus = 1

                // parameter to fail validation
                qt_min_contig_length = -1
            }
        }

        then {
            assert workflow.failed
            assert workflow.stderr.contains("* --qt_min_contig_length: -1 is not greater or equal to 1 (-1)")
        }
    }

    test("Test validation of databases parameters") {
        tag "fail_validation"

        when {
            params {
                input = "https://raw.githubusercontent.com/phac-nml/mikrokondo/dev/tests/data/samplesheets/samplesheet-small-assembly.csv"
                outdir = "results"

                platform = "illumina"

                mh_min_kmer = 1

                dehosting_idx = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy.mmi"

                kraken2_db = "$baseDir/tests/data/kraken2/test"

                min_reads = 100

                skip_bakta = true
                skip_staramr = false
                skip_mobrecon = false
                skip_checkm = false
                skip_raw_read_metrics = false
                skip_polishing = false

                max_memory = "2.GB"
                max_cpus = 1

                // parameter to fail validation
                mash_sketch = "invalid path"
            }
        }

        then {
            assert workflow.failed
            assert workflow.stderr.contains("* --mash_sketch: string [invalid path] does not match pattern ^\\S+\$ (invalid path)")
        }
    }

    test("Test validation of databases parameters check for file existence") {
        tag "fail_validation"

        when {
            params {
                input = "https://raw.githubusercontent.com/phac-nml/mikrokondo/dev/tests/data/samplesheets/samplesheet-small-assembly.csv"
                outdir = "results"

                platform = "illumina"

                mh_min_kmer = 1

                dehosting_idx = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy.mmi"

                kraken2_db = "$baseDir/tests/data/kraken2/test"

                min_reads = 100

                skip_bakta = true
                skip_staramr = false
                skip_mobrecon = false
                skip_checkm = false
                skip_raw_read_metrics = false
                skip_polishing = false

                max_memory = "2.GB"
                max_cpus = 1

                // parameter to fail validation
                mash_sketch = "./valid_path_non_existence"
            }
        }

        then {
            assert workflow.failed
            assert workflow.stderr.contains("* --mash_sketch: the file or directory './valid_path_non_existence' does not exist.")
        }
    }

    test("Test fail required database") {
        tag "fail_validation_required"

        when {
            params {
                input = "https://raw.githubusercontent.com/phac-nml/mikrokondo/dev/tests/data/samplesheets/samplesheet-small-assembly.csv"
                outdir = "results"

                platform = "illumina"

                mash_sketch = "https://github.com/phac-nml/mikrokondo/raw/dev/tests/data/databases/campy-staph-ecoli.msh"
                mh_min_kmer = 1

                // missing dehosting_idx

                kraken2_db = "$baseDir/tests/data/kraken2/test"

                min_reads = 100

                skip_bakta = true
                skip_staramr = false
                skip_mobrecon = false
                skip_checkm = false
                skip_raw_read_metrics = false
                skip_polishing = false

                max_memory = "2.GB"
                max_cpus = 1
            }
        }

        then {
            assert workflow.failed
            assert workflow.stderr.contains("* Missing required parameter: --dehosting_idx")
        }
    }
}
