/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Config file for defining DSL2 per module options and publishing paths
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Available keys to override module options:
        ext.args   = Additional arguments appended to command in module.
        ext.args2  = Second set of arguments appended to command in module (multi-tool modules).
        ext.args3  = Third set of arguments appended to command in module (multi-tool modules).
        ext.prefix = File name prefix for output files.
----------------------------------------------------------------------------------------
*/


def reformat_output(filename_in, outputtype, merge_string, meta_){
    /*
        filename_in ConfigObject: The file or directory being renamed. Can be treated as GString but not a file
        outputtype GString|null: string specifying the type of output to run, or null if there is not type
        merge_string Gstring: String to fill in as a tool name
        meta_: metadata passed in

        filename_in appears to be a ConfigObject preventing file methods from being called on the directory.
    */

    def allowed_compression_types = ["gz"]
    def output_type = outputtype
    def file_extension_delimiter = '.'

    def parent = filename_in.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
    def tokens = parent ? filename_in.tokenize(File.separator)[-1].tokenize(file_extension_delimiter) : filename_in.tokenize(file_extension_delimiter)
    output_type ? allowed_compression_types.contains(tokens[-1]) ? tokens.add(tokens.size() - 2, output_type) : tokens.add(tokens.size() - 1, output_type) : null

    def new_name = tokens[0].equals(meta_.id) ? meta_.id : "${meta_.id}.${tokens[0]}"
    def new_fn = "${new_name}.${merge_string}.${tokens[1..-1].join(file_extension_delimiter)}"
    def output = parent ? [parent, new_fn].join(File.separator) : new_fn
    return output
}


process {
    if(params.slurm_p){
        executor = 'slurm'
        queueSize = 10
        submitRateLimit = '100/2min'
        clusterOptions = "-p ${params.slurm_profile}"
    }


    assembly_directory_name = "Assembly"
    read_directory_name = "Reads"
    summaries_directory_name = "FinalReports"

    read_quality_directory_name = ["${params.outdir}", "${read_directory_name}", "Quality"].join(File.separator)
    read_trimmed_reports_directory_name = ["${read_quality_directory_name}", "Trimmed"].join(File.separator)
    read_final_processing_directory_name = ["${params.outdir}", "${read_directory_name}", "FinalReads"].join(File.separator)

    read_processing_directory_name = ["${params.outdir}", "${read_directory_name}", "Processing"].join(File.separator)
    read_decon_directory_name = ["${read_processing_directory_name}", "Dehosting"].join(File.separator)
    read_trimmed_directory_name = ["${read_decon_directory_name}", "Trimmed"].join(File.separator)
    read_downsampled_directory_name = ["${read_trimmed_directory_name}", "DownSampled"].join(File.separator)


    assembly_assembling_directory_name = ["${params.outdir}", "${assembly_directory_name}", "Assembling"].join(File.separator)
    assembly_consensus_directory_name = ["${assembly_assembling_directory_name}", "ConsensusGeneration"].join(File.separator)
    assembly_polishing_directory_name = ["${assembly_consensus_directory_name}", "Polishing"].join(File.separator)
    assembly_final_result_directory_name = ["${params.outdir}", "${assembly_directory_name}", "FinalAssembly"].join(File.separator)


    assembly_post_processing_directory_name = ["${params.outdir}", "${assembly_directory_name}", "PostProcessing"].join(File.separator)
    assembly_filtering_directory_name = ["${assembly_post_processing_directory_name}", "LengthFilteredContigs"].join(File.separator)
    assembly_post_speciation_directory_name = ["${assembly_post_processing_directory_name}", "Speciation"].join(File.separator)

    assembly_contigs_metagenomic_directory_name = ["${assembly_post_processing_directory_name}", "Metagenomic"].join(File.separator)
    assembly_contigs_binned_directory_name = ["${assembly_contigs_metagenomic_directory_name}", "BinnedContigs"].join(File.separator)

    assembly_annotations_directory_name = ["${params.outdir}", "${assembly_directory_name}", "Annotation"].join(File.separator)
    assembly_subtyping_directory_name = ["${params.outdir}", "${assembly_directory_name}", "Subtyping"].join(File.separator)
    assembly_quality_directory_name = ["${params.outdir}", "${assembly_directory_name}", "Quality"].join(File.separator)

    summaries_reports_directory_name = ["${params.outdir}", "${summaries_directory_name}"].join(File.separator)


    publishDir = [
        path: { "${params.outdir}/${task.process.tokenize(':')[-1].tokenize('_')[0].toLowerCase()}" },
        mode: params.publish_dir_mode,
        saveAs: { filename -> filename.equals('versions.yml') ? null : filename }
    ]

    withName: PUBLISH_FINAL_READS {
        ext.parameters = params.coreutils
        publishDir = [
            path: { "${task.read_final_processing_directory_name}" },
            mode: params.publish_dir_mode,
            pattern: "*/*",
            saveAs: { filename -> filename.equals('versions.yml') ? null : reformat_output(filename, "reads", "final", meta) }
        ]
    }

    withName: PUBLISH_FINAL_ASSEMBLIES {
        ext.parameters = params.coreutils
        publishDir = [
            path: { "${task.assembly_final_result_directory_name}" },
            mode: params.publish_dir_mode,
            pattern: "*/*",
            saveAs: { filename -> filename.equals('versions.yml') ? null : reformat_output(filename, "assembly", "final", meta) }
        ]
    }

    withName: LOCIDEX_EXTRACT {
        ext.parameters = params.locidex
        publishDir = [
            mode: params.publish_dir_mode,
            path: { ["${task.assembly_subtyping_directory_name}", "Locidex", "Extract"].join(File.separator) },
            pattern: "*/*${params.locidex.extracted_seqs_suffix}",
            saveAs: { filename -> filename.equals('versions.yml') ? null : reformat_output(filename, "subtyping", "locidex.extract", meta) }
        ]
    }

    withName: LOCIDEX_SEARCH {
        ext.parameters = params.locidex
        publishDir = [
            [
                mode: params.publish_dir_mode,
                path: { ["${task.assembly_subtyping_directory_name}", "Locidex", "Search"].join(File.separator) },
                pattern: "*${params.locidex.seq_store_suffix}",
                saveAs: { filename -> filename.equals('versions.yml') ? null : reformat_output(filename, null, "locidex", meta) }
            ],
            [
                mode: params.publish_dir_mode,
                path: { ["${task.assembly_subtyping_directory_name}", "Locidex", "Search"].join(File.separator) },
                pattern: "*${params.locidex.gbk_suffix}",
                saveAs: { filename -> filename.equals('versions.yml') ? null : reformat_output(filename, "annotation", "locidex", meta) }
            ]
        ]
    }

    withName: LOCIDEX_REPORT {
        ext.parameters = params.locidex
        publishDir = [
            mode: params.publish_dir_mode,
            path: { ["${task.assembly_subtyping_directory_name}", "Locidex", "Report"].join(File.separator) },
            pattern: "*${params.locidex.report_suffix}",
            saveAs: { filename -> filename.equals('versions.yml') ? null : reformat_output(filename, "subtyping", "locidex.report", meta) }
        ]
    }

    withName: REPORT{
            executor = 'local'
            cache = 'false' // Resume does not work on module, if enabled a warning is thrown
            errorStrategy = "terminate"
            publishDir = [
                mode: params.publish_dir_mode,
                path: { ["${task.summaries_reports_directory_name}", "Aggregated", "Json"].join(File.separator) },
                pattern: "final_report.json",
            ]
    }

    withName: IDENTIFY_POINTDB {
        executor = 'local'
        errorStrategy = "ignore"
    }

    withName: REPORT_AGGREGATE {
        ext.parameters = params.python3
        cache = 'false' // Resume does not work on module, if enabled a warning is thrown
        errorStrategy = "terminate"
        publishDir = [
            [
                mode: params.publish_dir_mode,
                path: { ["${task.summaries_reports_directory_name}", "Aggregated", "Tables"].join(File.separator) },
                pattern: "*.tsv",
            ],
            [
                mode: params.publish_dir_mode,
                path: { ["${task.summaries_reports_directory_name}", "Sample", "Json"].join(File.separator) },
                pattern: "*.json",
            ]

        ]
    }


    withName: BIN_KRAKEN2 {
        ext.parameters = params.python3
        maxForks = 20

        publishDir = [
            mode: params.publish_dir_mode,
            path: { ["${task.assembly_contigs_binned_directory_name}", "Kraken2"].join(File.separator) },
            pattern: "*${params.kraken_bin.fasta_ext}",
            saveAs: { filename -> filename.equals('versions.yml') ? null : reformat_output(filename, "assembly", "kraken2", meta) }
        ]
    }


    withName: COMBINE_DATA {
        ext.parameters = params.coreutils
        publishDir = [
            enabled: false
        ]
    }


    withName: GZIP_FILES {
        ext.parameters = params.coreutils
        publishDir = [
            [
                mode: params.publish_dir_mode,
                path: { ["${task.summaries_reports_directory_name}", "FlattenedReports"].join(File.separator) },
                pattern: "*.gz"
            ]
        ]
    }

    withName: CHECK_ONT {
        ext.parameters = params.python3
        publishDir = [
            enabled: false
        ]

    }

    withName: PARSE_MASH {
        ext.parameters = params.python3
        errorStrategy = { task.exitStatus == 255 || task.exitStatus == 1 ? 'ignore' : 'finish'}
        publishDir = [
            enabled: false
        ]
    }

    withName: PARSE_KRAKEN {
        ext.parameters = params.python3
        errorStrategy = { task.exitStatus == 255 || task.exitStatus == 1 ? 'ignore' : 'finish'}
        publishDir = [
            enabled: false
        ]
    }

    withName: READ_SCAN {
        errorStrategy = "terminate"
        ext.parameters = params.python3
        publishDir = [
            [
                mode: params.publish_dir_mode,
                path: { [task.read_quality_directory_name, "RawReadQuality"].join(File.separator) },
                pattern: "*.json",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "summary", "read.scan", meta) }
            ],
        ]
    }

    withName: PARSE_FASTP {
        executor = 'local'
        publishDir = [
            enabled: false
        ]
    }

    withName: FASTQC {
        ext.args = '--quiet'
        publishDir = [
            [
                path: "${params.outdir}/ReadQuality/fastqc",
                mode: params.publish_dir_mode,
                pattern: "*{${params.fastqc.html_ext},${params.fastqc.zip_ext}}",
            ]
        ]
    }

    withName: SEQKIT_STATS {
        ext.args = ""
        ext.parameters = params.seqkit
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_quality_directory_name}", "SeqKitStats"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.seqkit.report_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "summary", "seqkit.stats", meta) }
            ]
        ]
    }

    withName: SEQKIT_FILTER {
        ext.args = ""
        ext.parameters = params.seqkit
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_filtering_directory_name}", "SeqKitFilter"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.seqkit.fasta_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "assembly", "seqkit.filter", meta) }
            ]
        ]
    }

    withName: SEQTK_SAMPLE {
        ext.args = ""
        ext.parameters = params.seqtk
        stageInMode = params.stage_in_mode
        // scratch = false
        publishDir = [
            [
                path: { [ "${task.read_downsampled_directory_name}", "SeqTK" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.seqtk.reads_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "reads", "seqtk.sample", meta) }
            ]
        ]
    }


    withName: SEQTK_SIZE {
        ext.args = ""
        ext.parameters = params.seqtk_size
        stageInMode = params.stage_in_mode
        // scratch = false
        publishDir = [
            [
                path: { ["${task.read_final_processing_directory_name}", "BaseCounts"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*.txt",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "seqtk.size", meta) }
            ]
        ]
    }



    withName: QUAST {
        ext.args = params.quast.args
        ext.parameters = params.quast
        stageInMode = params.stage_in_mode
        // scratch = false
        //errorStrategy = { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
        errorStrategy = 'ignore'
        maxForks = 10 // Quast can get overloaded by job subs, so needs to be limited
        publishDir = [
            [
                path: { ["${task.assembly_quality_directory_name}", "QUAST"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*/**",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "quality", "quast", meta) }
            ]
        ]

    }

    withName: CHECKM_LINEAGEWF {
        ext.args = ""
        //container = params.checkm.container
        ext.parameters = params.checkm
        stageInMode = params.stage_in_mode
        //errorStrategy = { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
        errorStrategy = 'ignore'
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_quality_directory_name}", "CheckM"].join(File.separator) } ,
                mode: params.publish_dir_mode,
                pattern: "*/**",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "quality", "checkm", meta) }
            ]
        ]
    }

    withName: BANDAGE_IMAGE {
        ext.args = ""
        //container = params.bandage.container
        ext.parameters = params.bandage
        //errorStrategy = { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
        errorStrategy = 'ignore'
        stageInMode = params.stage_in_mode
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_assembling_directory_name}", "Bandage"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.bandage.svg_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "quality", "bandage", meta) }
            ]
        ]
    }

    withName: KRAKEN {
        ext.args = ""
        //container = params.kraken.container
        ext.parameters = params.kraken
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "Kraken2", "Classified"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*.${params.kraken.classified_suffix}*",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, null, "kraken2", meta) }
            ],
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "Kraken2", "UnClassified"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*.${params.kraken.unclassified_suffix}*",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, null, "kraken2", meta) }
            ],
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "Kraken2", "Report"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*.kraken2.${params.kraken.report_suffix}.txt",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "screen", "kraken2", meta) }
            ],
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "Kraken2", "Output"].join(File.separator) } ,
                mode: params.publish_dir_mode,
                pattern: "*.${params.kraken.output_suffix}.txt",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, null, "kraken2", meta) }
            ]

        ]
    }


    withName: MASH_ESTIMATE {
        ext.parameters = params.mash
        // scratch = false
        maxForks = 20
        maxRetries = 3
        maxErrors = 3
        stageInMode = params.stage_in_mode
            publishDir = [
                [
                    path: { ["${task.read_trimmed_directory_name}", "MashSketches"].join(File.separator) } ,
                    mode: params.publish_dir_mode,
                    pattern: "*${params.mash.sketch_ext}",
                    saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "mash.estimate", meta) }
                ]
            ]

    }

    withName: MLST {
        //container = params.mlst.container
        ext.parameters = params.mlst
        // scratch = false
        stageInMode = params.stage_in_mode
        errorStrategy = 'ignore'
        publishDir = [
                [
                    path: { ["${task.assembly_subtyping_directory_name}", "SevenGeneMLST"].join(File.separator) } ,
                    mode: params.publish_dir_mode,
                    pattern: "*${params.mlst.json_ext}",
                    saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "subtyping", "7.mlst", meta) }
                ]
            ]

    }


    withName: STARAMR {
        ext.parameters = params.staramr
        ext.args = params.staramr.args
        errorStrategy = 'ignore'
        publishDir = [
                [
                    path: { ["${task.assembly_annotations_directory_name}", "StarAMR"].join(File.separator) },
                    mode: params.publish_dir_mode,
                    saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "annotation", "staramr", meta) }
                ]
            ]
    }

    withName: MOBSUITE_RECON {
        ext.parameters = params.mobsuite_recon
        stageInMode = params.stage_in_mode
        errorStrategy = 'ignore'
        ext.args = params.mobsuite_recon.args
        publishDir = [
                [
                    path: { ["${task.assembly_annotations_directory_name}", "Mobsuite", "Recon"].join(File.separator) },
                    mode: params.publish_dir_mode,
                    pattern: "*/*",
                    saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "annotation", "mob.recon", meta) }
                ]
            ]
    }

    withName: MASH_SKETCH {
        //container = params.mash.container
        maxForks = 20
        ext.parameters = params.mash
        // scratch = false
        maxRetries = 3
        maxErrors = 3
        stageInMode = params.stage_in_mode
        // No publishing as the way this is being used will create MASSIVE amounts of files
    }


    withName: MASH_PASTE {
        //container = params.mash.container
        ext.parameters = params.mash
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: "${params.outdir}/sketch",
                mode: params.publish_dir_mode,
                pattern: "*${params.mash.sketch_ext}"
            ]
        ]
    }

    withName: MASH_SCREEN {
        def dir_out = null
        //errorStrategy = { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
        errorStrategy = 'ignore'
        maxForks = 20
        maxErrors = 3
        ext.args = "-w"
        ext.parameters = params.mash
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.read_trimmed_reports_directory_name}", "MashScreen" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.mash.output_reads_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "screen", "mash.screen", meta) }
            ],
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "MashScreen"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.mash.output_taxa_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "screen", "mash.screen", meta) }
            ]
        ]
    }


    withName: REMOVE_CONTAMINANTS {
        ext.args = "-a" // output sam format in minimap2
        ext.parameters = params.r_contaminants
        //container = params.r_contaminants.container
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { "${task.read_decon_directory_name}" },
                mode: params.publish_dir_mode,
                pattern: "*.gz",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "reads", "deconned", meta) }
            ]
        ]
    }

    withName: FLYE_ASSEMBLE {
        //errorStrategy = { task.exitStatus in [140] ? 'retry' : 'ignore'}
        errorStrategy = 'ignore'
        //container = params.flye.container
        ext.parameters = params.flye
        ext.args = params.flye.args
        maxRetries = 3
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Contigs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.fasta_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "assembly", "flye", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Graphs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.gfa_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "graph", "flye", meta) }
            ],
            [   path: { ["${task.assembly_assembling_directory_name}", "Flye", "gv" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.gv_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "flye", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Summary" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.txt_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "flye", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Log" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.log_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "flye", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Json" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.json_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "flye", meta) }
            ]
        ]
    }


    withName: SPADES_ASSEMBLE {
        maxRetries = 3
        ext.args = ""
        ext.parameters = params.spades
        //errorStrategy = { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
        errorStrategy = 'ignore'
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Scaffolds" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.scaffolds_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "spades", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Contigs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.contigs_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "assembly", "spades", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Transcripts" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.transcripts_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "spades", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "GeneClusters" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.gene_clusters_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "spades", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Logs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.log_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "spades", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Graphs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.assembly_graphs_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "graph", "spades", meta) }
            ]
        ]
    }



    withName: UNICYCLER_ASSEMBLE {
        ext.args = ""
        //container = params.unicycler.container
        ext.parameters = params.unicycler
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_assembling_directory_name}", "Unicycler", "Scaffolds" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.unicycler.scaffolds_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "unicylcer", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Unicycler", "Assembly" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.unicycler.assembly_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "assembly", "unicycler", meta) }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Unicycler", "Logs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.unicycler.log_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, null, "unicycler", meta) }
            ]
        ]
    }


    withName: FASTP_TRIM {
        //ext.args = ""
        //container = params.fastp.container
        ext.parameters = params.fastp
        // scratch = false
        publishDir = [
                [
                    path: { ["${task.read_trimmed_directory_name}", "FastP"].join(File.separator) },
                    mode: params.publish_dir_mode,
                    pattern: "*${params.fastp.fastq_ext}",
                    saveAs: { filename ->
                            filename.equals('versions.yml') ? null : reformat_output(filename, "reads", "fastp", meta) }
                ],
                [
                    path: { ["${task.read_trimmed_reports_directory_name}", "FastP"].join(File.separator) },
                    mode: params.publish_dir_mode,
                    pattern: "*{${params.fastp.json_ext},${params.fastp.html_ext}}",
                    saveAs: { filename ->
                            filename.equals('versions.yml') ? null : reformat_output(filename, "summary", "fastp", meta) }
                ]

        ]
    }



    withName: MINIMAP2_INDEX {
        ext.args = ""
        //container = params.minimap2.container
        ext.parameters = params.minimap2
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            enabled: false
        ]
    }

    withName: MINIMAP2_MAP {
        ext.args = ""
        //container = params.minimap2.container
        ext.parameters = params.minimap2
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            enabled: false
        ]
    }

    withName: SAM_TO_BAM {
        //container = params.samtools.container
        ext.parameters = params.samtools
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            enabled: false
        ]
    }

    withName: RACON_POLISH {
        ext.args = ""
        //container = params.racon.container
        ext.parameters = params.racon
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: {  ["${task.assembly_consensus_directory_name}", "Racon", "Consensus"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.racon.consensus_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "assembly", "racon", meta) }
            ]
        ]
    }


    withName: PILON_ITER {
        ext.args = ""
        stageInMode = params.stage_in_mode
        // scratch = false
        ext.parameters = params.pilon_iterative
        maxRetries = 3
        //errorStrategy = { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
        errorStrategy = 'ignore'
        publishDir = [
            [
                path: { ["${task.assembly_polishing_directory_name}", "Pilon", "Fasta"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.pilon_iterative.fasta_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : reformat_output(filename, "assembly", "pilon", meta) }
            ],
            [
                path: { ["${task.assembly_polishing_directory_name}", "Pilon", "VCF"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.pilon_iterative.vcf_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "vcf", "pilon", meta) }
            ],
            [
                path: { ["${task.assembly_polishing_directory_name}", "Pilon", "Changes"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.pilon_iterative.changes_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, null, "pilon", meta) }
            ],
            [
                path: { ["${task.assembly_polishing_directory_name}", "Pilon", "BAMs"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.pilon_iterative.bam_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "bam", "pilon", meta) }
            ]
        ]
    }


    withName: MEDAKA_POLISH{
        ext.args = ""
        cache = 'lenient'
        stageInMode = params.stage_in_mode
        // scratch = false
        ext.parameters = params.medaka
        maxRetries = 3
        publishDir = [
            [
                path: { ["${task.assembly_polishing_directory_name}", "Medaka"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.medaka.fasta_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "assembly", "medaka", meta) }
            ]
        ]
    }

    withName: BAKTA_DB_DOWNLOAD {
        // scratch = false
        ext.parameters = params.bakta
        stageInMode = params.stage_in_mode
    }

    withName: BAKTA_ANNOTATE {
        // scratch = false // bakta uses its own temp dir so things get weird
        errorStrategy = 'ignore' // Some samples do not run through MikroKondo
        ext.parameters = params.bakta
        ext.args = params.bakta.args
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_annotations_directory_name}", "Bakta"].join(File.separator) },
                mode: params.publish_dir_mode,
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "annotation", "bakta", meta) }
            ]
        ]

    }

    withName: ABRICATE {
        errorStrategy = 'ignore'
        ext.args = params.abricate.args
        ext.parameters = params.abricate
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_annotations_directory_name}", "Abricate"].join(File.separator) },
                mode: params.publish_dir_mode,
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : reformat_output(filename, "annotation", "abricate", meta) }
            ]
        ]
    }

    withName: ECTYPER {
        ext.parameters = params.ectyper
        stageInMode = params.stage_in_mode
        ext.args = params.ectyper.args
        time = '30m'
        // scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "ECTyper"].join(File.separator) },
            mode: params.publish_dir_mode,
            pattern: "*/*",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : reformat_output(filename, "subtyping", "ectyper", meta) }
        ]
    }

    withName: KLEBORATE {
        ext.parameters = params.kleborate
        stageInMode = params.stage_in_mode
        // scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "Kleborate"].join(File.separator) },
            mode: params.publish_dir_mode,
            pattern: "*${params.kleborate.txt_ext}",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : reformat_output(filename, "subtyping", "kleborate", meta) }
        ]
    }

    withName: SPATYPER {
        ext.parameters = params.spatyper
        stageInMode = params.stage_in_mode
        //scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "SpaTyper"].join(File.separator) },
            mode: params.publish_dir_mode,
            pattern: "*${params.spatyper.tsv_ext}",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : reformat_output(filename, "subtyping", "spatyper", meta) }
        ]
    }


    withName: SISTR {
        ext.parameters = params.sistr
        stageInMode = params.stage_in_mode
        //scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "SISTR"].join(File.separator) },
            mode: params.publish_dir_mode,
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : reformat_output(filename, "subtyping", "sistr", meta) }
        ]
    }

    withName: LISSERO {
        ext.parameters = params.lissero
        stageInMode = params.stage_in_mode
        //scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "Lissero"].join(File.separator) },
            mode: params.publish_dir_mode,
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : reformat_output(filename, "subtyping", "lissero", meta) }
        ]
    }

    withName: SHIGEIFINDER {
        ext.parameters = params.shigeifinder
        stageInMode = params.stage_in_mode
        scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "ShigeiFinder"].join(File.separator) } ,
            mode: params.publish_dir_mode,
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : reformat_output(filename, "subtyping", "shigeifinder", meta) }
        ]
    }


    withName: CUSTOM_DUMPSOFTWAREVERSIONS {
        publishDir = [
            path: { "${params.outdir}/pipeline_info" },
            mode: params.publish_dir_mode,
            pattern: '*_versions.yml'
        ]
    }


}
