/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Config file for defining DSL2 per module options and publishing paths
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Available keys to override module options:
        ext.args   = Additional arguments appended to command in module.
        ext.args2  = Second set of arguments appended to command in module (multi-tool modules).
        ext.args3  = Third set of arguments appended to command in module (multi-tool modules).
        ext.prefix = File name prefix for output files.
----------------------------------------------------------------------------------------
*/

// TODO tie all ext.args to nextflow.config
// TODO mix in versions of all outputs

process {
    if(params.slurm_p){
        executor = 'slurm'
        queueSize = 10
        submitRateLimit = '100/2min'
        clusterOptions = "-p ${params.slurm_profile}"
    }

    assembly_directory_name = "Assembly"
    read_directory_name = "Reads"
    summaries_directory_name = "FinalReports"

    read_quality_directory_name = ["${params.outdir}", "${read_directory_name}", "Quality"].join(File.separator)
    read_trimmed_reports_directory_name = ["${read_quality_directory_name}", "Trimmed"].join(File.separator)
    read_final_processing_directory_name = ["${params.outdir}", "${read_directory_name}", "FinalReads"].join(File.separator)

    read_processing_directory_name = ["${params.outdir}", "${read_directory_name}", "Processing"].join(File.separator)
    read_decon_directory_name = ["${read_processing_directory_name}", "Dehosting"].join(File.separator)
    read_trimmed_directory_name = ["${read_decon_directory_name}", "Trimmed"].join(File.separator)
    read_downsampled_directory_name = ["${read_trimmed_directory_name}", "DownSampled"].join(File.separator)


    assembly_assembling_directory_name = ["${params.outdir}", "${assembly_directory_name}", "Assembling"].join(File.separator)
    assembly_consensus_directory_name = ["${assembly_assembling_directory_name}", "ConsensusGeneration"].join(File.separator)
    assembly_polishing_directory_name = ["${assembly_consensus_directory_name}", "Polishing"].join(File.separator)
    assembly_final_result_directory_name = ["${params.outdir}", "${assembly_directory_name}", "FinalAssembly"].join(File.separator)


    assembly_post_processing_directory_name = ["${params.outdir}", "${assembly_directory_name}", "PostProcessing"].join(File.separator)
    assembly_filtering_directory_name = ["${assembly_post_processing_directory_name}", "LengthFilteredContigs"].join(File.separator)
    assembly_post_speciation_directory_name = ["${assembly_post_processing_directory_name}", "Speciation"].join(File.separator)

    assembly_contigs_metagenomic_directory_name = ["${assembly_post_processing_directory_name}", "Metagenomic"].join(File.separator)
    assembly_contigs_binned_directory_name = ["${assembly_contigs_metagenomic_directory_name}", "BinnedContigs"].join(File.separator)

    assembly_annotations_directory_name = ["${params.outdir}", "${assembly_directory_name}", "Annotation"].join(File.separator)
    assembly_subtyping_directory_name = ["${params.outdir}", "${assembly_directory_name}", "Subtyping"].join(File.separator)
    assembly_quality_directory_name = ["${params.outdir}", "${assembly_directory_name}", "Quality"].join(File.separator)

    summaries_reports_directory_name = ["${params.outdir}", "${summaries_directory_name}"].join(File.separator)


    publishDir = [
        path: { "${params.outdir}/${task.process.tokenize(':')[-1].tokenize('_')[0].toLowerCase()}" },
        mode: params.publish_dir_mode,
        saveAs: { filename -> filename.equals('versions.yml') ? null : filename }
    ]

    withName: PUBLISH_FINAL_READS {
        ext.containers = params.coreutils
        publishDir = [
            path: { "${task.read_final_processing_directory_name}" },
            mode: params.publish_dir_mode,
            pattern: "*/*",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
					def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.final.reads.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }

    withName: PUBLISH_FINAL_ASSEMBLIES {
        ext.containers = params.coreutils
        publishDir = [
            path: { "${task.assembly_final_result_directory_name}" },
            mode: params.publish_dir_mode,
            pattern: "*/*",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
					def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.final.assembly.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }

    withName: LOCIDEX_EXTRACT {
        ext.parameters = params.locidex
        publishDir = [
            mode: params.publish_dir_mode,
            path: { ["${task.assembly_subtyping_directory_name}", "Locidex", "Extract"].join(File.separator) },
            pattern: "*/*${params.locidex.extracted_seqs_suffix}",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
					def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.locidex.extract.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }

    withName: LOCIDEX_SEARCH {
        ext.parameters = params.locidex
        publishDir = [
            [
                mode: params.publish_dir_mode,
                path: { ["${task.assembly_subtyping_directory_name}", "Locidex", "Search"].join(File.separator) },
                pattern: "*${params.locidex.seq_store_suffix}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
					def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.locidex.seq_store.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
            ],
            [
                mode: params.publish_dir_mode,
                path: { ["${task.assembly_subtyping_directory_name}", "Locidex", "Search"].join(File.separator) },
                pattern: "*${params.locidex.gbk_suffix}",
                saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
					def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.locidex.annotations.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
            ]
        ]
    }

    withName: LOCIDEX_REPORT {
        ext.parameters = params.locidex
        publishDir = [
            mode: params.publish_dir_mode,
            path: { ["${task.assembly_subtyping_directory_name}", "Locidex", "Report"].join(File.separator) },
            pattern: "*${params.locidex.report_suffix}",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
					def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.locidex.report.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }

    withName: REPORT{
            executor = 'local'
            cache = 'false' // Resume does not work on module, if enabled a warning is thrown
            errorStrategy = "terminate"
            publishDir = [
                mode: params.publish_dir_mode,
                path: { ["${task.summaries_reports_directory_name}", "Aggregated", "Json"].join(File.separator) },
                pattern: "final_report.json",
            ]
    }

    withName: IDENTIFY_POINTDB {
        executor = 'local'
        errorStrategy = "ignore"
    }

    withName: REPORT_AGGREGATE {
        ext.containers = params.python3
        cache = 'false' // Resume does not work on module, if enabled a warning is thrown
        errorStrategy = "terminate"
        publishDir = [
            [
                mode: params.publish_dir_mode,
                path: { ["${task.summaries_reports_directory_name}", "Aggregated", "Tables"].join(File.separator) },
                pattern: "*.tsv",
            ],
            [
                mode: params.publish_dir_mode,
                path: { ["${task.summaries_reports_directory_name}", "Sample", "Json"].join(File.separator) },
                pattern: "*.json",
            ]

        ]
    }


    withName: BIN_KRAKEN2 {
        ext.containers = params.python3
        maxForks = 20

        publishDir = [
            mode: params.publish_dir_mode,
            path: { ["${task.assembly_contigs_binned_directory_name}", "Kraken2"].join(File.separator) },
            pattern: "*${params.kraken_bin.fasta_ext}",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
					def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.binned.kraken2.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }


    withName: COMBINE_DATA {
        ext.containers = params.coreutils
        publishDir = [
            enabled: false
        ]
    }


    withName: GZIP_FILES {
        ext.containers = params.coreutils
        publishDir = [
            [
                mode: params.publish_dir_mode,
                path: { ["${task.summaries_reports_directory_name}", "FlattenedReports"].join(File.separator) },
                pattern: "*.gz"
            ]
        ]
    }

    withName: CHECK_ONT {
        ext.containers = params.python3
        publishDir = [
            enabled: false
        ]

    }

    withName: PARSE_MASH {
        ext.containers = params.python3
        errorStrategy = { task.exitStatus == 255 || task.exitStatus == 1 ? 'ignore' : 'finish'}
        publishDir = [
            enabled: false
        ]
    }

    withName: PARSE_KRAKEN {
        ext.containers = params.python3
        errorStrategy = { task.exitStatus == 255 || task.exitStatus == 1 ? 'ignore' : 'finish'}
        publishDir = [
            enabled: false
        ]
    }

    withName: READ_SCAN {
        errorStrategy = "terminate"
        ext.containers = params.python3
        publishDir = [
            [
                mode: params.publish_dir_mode,
                path: { [task.read_quality_directory_name, "RawReadQuality"].join(File.separator) },
                pattern: "*.json",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.read.scan.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ],
        ]
    }

    withName: PARSE_FASTP {
        executor = 'local'
        publishDir = [
            enabled: false
        ]
    }

    withName: FASTQC {
        ext.args = '--quiet'
        publishDir = [
            [
                path: "${params.outdir}/ReadQuality/fastqc",
                mode: params.publish_dir_mode,
                pattern: "*{${params.fastqc.html_ext},${params.fastqc.zip_ext}}",
            ]
        ]
    }

    withName: SEQKIT_STATS {
        ext.args = ""
        ext.containers = params.seqkit
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_quality_directory_name}", "SeqKitStats"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.seqkit.report_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.seqkit.stats.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]
    }

    withName: SEQKIT_FILTER {
        ext.args = ""
        ext.containers = params.seqkit
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_filtering_directory_name}", "SeqKitFilter"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.seqkit.fasta_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.seqkit.filter.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]
    }

    withName: SEQTK_SAMPLE {
        ext.args = ""
        ext.containers = params.seqtk
        stageInMode = params.stage_in_mode
        // scratch = false
        publishDir = [
            [
                path: { [ "${task.read_downsampled_directory_name}", "SeqTK" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.seqtk.reads_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.seqtk.sample.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]
    }


    withName: SEQTK_SIZE {
        ext.args = ""
        ext.containers = params.seqtk_size
        stageInMode = params.stage_in_mode
        // scratch = false
        publishDir = [
            [
                path: { ["${task.read_final_processing_directory_name}", "BaseCounts"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*.txt",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.seqtk.size.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]
    }



    withName: QUAST {
        ext.args = params.quast.args
        ext.containers = params.quast
        stageInMode = params.stage_in_mode
        // scratch = false
        errorStrategy = { task.attempt <= task.maxRetries ? sleep(Math.pow(2, task.attempt) * 200 as long) &&  'retry' : 'ignore' }
        maxForks = 10 // Quast can get overloaded by job subs, so needs to be limited
        publishDir = [
            [
                path: { ["${task.assembly_quality_directory_name}", "QUAST"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*/**",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.quast.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]

    }

    withName: CHECKM_LINEAGEWF {
        ext.args = ""
        //container = params.checkm.container
        ext.containers = params.checkm
        stageInMode = params.stage_in_mode
        errorStrategy = { task.attempt <= task.maxRetries ? sleep(Math.pow(2, task.attempt) * 200 as long) && 'retry' : 'finish' }
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_quality_directory_name}", "CheckM"].join(File.separator) } ,
                mode: params.publish_dir_mode,
                pattern: "*/**",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.checkm.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ]
        ]
    }

    withName: BANDAGE_IMAGE {
        ext.args = ""
        //container = params.bandage.container
        ext.containers = params.bandage
        errorStrategy = { task.attempt <= task.maxRetries ? sleep(Math.pow(2, task.attempt) * 200 as long) && 'retry' : 'ignore' }
        stageInMode = params.stage_in_mode
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_assembling_directory_name}", "Bandage"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.bandage.svg_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.bandage.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]
    }

    withName: KRAKEN {
        ext.args = ""
        //container = params.kraken.container
        ext.containers = params.kraken
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "Kraken2", "Classified"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*.${params.kraken.classified_suffix}*",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.kraken2.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ],
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "Kraken2", "UnClassified"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*.${params.kraken.unclassified_suffix}*",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.kraken2.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ],
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "Kraken2", "Report"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*.kraken2.${params.kraken.report_suffix}.txt",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.kraken2.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ],
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "Kraken2", "Output"].join(File.separator) } ,
                mode: params.publish_dir_mode,
                pattern: "*.${params.kraken.output_suffix}.txt",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.kraken2.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]

        ]
    }


    withName: MASH_ESTIMATE {
        ext.containers = params.mash
        // scratch = false
        maxForks = 20
        maxRetries = 3
        maxErrors = 3
        stageInMode = params.stage_in_mode
            publishDir = [
                [
                    path: { ["${task.read_trimmed_directory_name}", "MashSketches"].join(File.separator) } ,
                    mode: params.publish_dir_mode,
                    pattern: "*${params.mash.sketch_ext}",
                    saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.mash.estimate.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                    }
                ]
            ]

    }

    withName: MLST {
        //container = params.mlst.container
        ext.containers = params.mlst
        // scratch = false
        stageInMode = params.stage_in_mode
        errorStrategy = 'ignore'
        publishDir = [
                [
                    path: { ["${task.assembly_subtyping_directory_name}", "SevenGeneMLST"].join(File.separator) } ,
                    mode: params.publish_dir_mode,
                    pattern: "*${params.mlst.json_ext}",
                    saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.7.mlst.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                    }
                ]
            ]

    }

    withName: STARAMR_DUMP_DB_VERSIONS {
        ext.containers = params.staramr
        ext.args = params.staramr.args
        errorStrategy = 'ignore'
        publishDir = [
            [
                path: { ["${task.assembly_annotations_directory_name}", "StarAMR"].join(File.separator) },
                mode: params.publish_dir_mode,
            ]
        ]
    }

    withName: STARAMR {
        ext.containers = params.staramr
        ext.args = params.staramr.args
        errorStrategy = 'ignore'
        publishDir = [
                [
                    path: { ["${task.assembly_annotations_directory_name}", "StarAMR"].join(File.separator) },
                    mode: params.publish_dir_mode,
                    pattern: "*/*",
                    saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.staramr.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                    }
                ]
            ]
    }

    withName: MOBSUITE_RECON {
        ext.containers = params.mobsuite_recon
        stageInMode = params.stage_in_mode
        errorStrategy = 'ignore'
        ext.args = params.mobsuite_recon.args
        publishDir = [
                [
                    path: { ["${task.assembly_annotations_directory_name}", "Mobsuite", "Recon"].join(File.separator) },
                    mode: params.publish_dir_mode,
                    pattern: "*/*",
                    saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.mob.recon.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                    }
                ]
            ]
    }

    withName: MASH_SKETCH {
        //container = params.mash.container
        maxForks = 20
        ext.containers = params.mash
        // scratch = false
        maxRetries = 3
        maxErrors = 3
        stageInMode = params.stage_in_mode
        // No publishing as the way this is being used will create MASSIVE amounts of files
    }


    withName: MASH_PASTE {
        //container = params.mash.container
        ext.containers = params.mash
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: "${params.outdir}/sketch",
                mode: params.publish_dir_mode,
                pattern: "*${params.mash.sketch_ext}"
            ]
        ]
    }

    withName: MASH_SCREEN {
        def dir_out = null
        errorStrategy = { sleep(Math.pow(2, task.attempt) * 200 as long)
            return 'retry' }
        maxForks = 20
        maxErrors = 3
        //dir_out =  process.toString().contains("QC_READS") ? "ReadQuality/${params.mash.output_dir}/mash" : "taxon_determination/mash"
        ext.args = "-w"
        //container = params.mash.container
        ext.containers = params.mash
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.read_trimmed_reports_directory_name}", "MashScreen" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.mash.output_reads_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.mash.screen.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ],
            [
                path: { ["${task.assembly_post_speciation_directory_name}", "MashScreen"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.mash.output_taxa_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.mash.screen.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]
    }


    withName: REMOVE_CONTAMINANTS {
        ext.args = "-a" // output sam format in minimap2
        ext.containers = params.r_contaminants
        //container = params.r_contaminants.container
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { "${task.read_decon_directory_name}" },
                mode: params.publish_dir_mode,
                pattern: "*.gz",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.deconned.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ]
        ]
    }

    withName: FLYE_ASSEMBLE {
        errorStrategy = { task.exitStatus in [140] ? 'retry' : 'ignore'}
        //container = params.flye.container
        ext.containers = params.flye
        ext.args = params.flye.args
        maxRetries = 3
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Contigs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.fasta_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.flye.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Graphs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.gfa_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.flye.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [   path: { ["${task.assembly_assembling_directory_name}", "Flye", "gv" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.gv_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.flye.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Summary" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.txt_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.flye.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Log" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.log_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.flye.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Flye", "Json" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.flye.json_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.flye.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ]
        ]
    }


    withName: SPADES_ASSEMBLE {
        maxRetries = 3
        ext.args = ""
        ext.containers = params.spades
        errorStrategy = 'ignore'
        //errorStrategy = { task.attempt <= task.maxRetries && sleep(Math.pow(2, task.attempt) * 200 as long) ? 'retry' : 'ignore' }
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Scaffolds" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.scaffolds_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.spades.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Contigs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.contigs_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.spades.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Transcripts" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.transcripts_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.spades.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "GeneClusters" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.gene_clusters_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.spades.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Logs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.log_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.spades.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Spades", "Graphs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.spades.assembly_graphs_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.spades.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ]
        ]
    }



    withName: UNICYCLER_ASSEMBLE {
        ext.args = ""
        //container = params.unicycler.container
        ext.containers = params.unicycler
        // scratch = false
        publishDir = [
            [
                path: { ["${task.assembly_assembling_directory_name}", "Unicycler", "Scaffolds" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.unicycler.scaffolds_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.unicycler.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Unicycler", "Assembly" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.unicycler.assembly_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.unicycler.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_assembling_directory_name}", "Unicycler", "Logs" ].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.unicycler.log_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.unicycler.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ]
        ]
    }


    withName: FASTP_TRIM {
        //ext.args = ""
        //container = params.fastp.container
        ext.containers = params.fastp
        // scratch = false
        publishDir = [
                [
                    path: { ["${task.read_trimmed_directory_name}", "FastP"].join(File.separator) },
                    mode: params.publish_dir_mode,
                    pattern: "*${params.fastp.fastq_ext}",
                    saveAs: { filename ->
                            filename.equals('versions.yml') ? null : {
                                def tokens = filename.tokenize(".")
                                def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                                def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                                def new_fn = "${new_name}.fastp.${tokens[1..-1].join(".")}"
                                output = parent ? [parent, new_fn].join(File.separator) : new_fn
                            }.call()
                    }
                ],
                [
                    path: { ["${task.read_trimmed_reports_directory_name}", "FastP"].join(File.separator) },
                    mode: params.publish_dir_mode,
                    pattern: "*{${params.fastp.json_ext},${params.fastp.html_ext}}",
                    saveAs: { filename ->
                            filename.equals('versions.yml') ? null : {
                                def tokens = filename.tokenize(".")
                                def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                                def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                                def new_fn = "${new_name}.fastp.${tokens[1..-1].join(".")}"
                                output = parent ? [parent, new_fn].join(File.separator) : new_fn
                            }.call()
                    }
                ]

        ]
    }



    withName: MINIMAP2_INDEX {
        ext.args = ""
        //container = params.minimap2.container
        ext.containers = params.minimap2
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            enabled: false
        ]
    }

    withName: MINIMAP2_MAP {
        ext.args = ""
        //container = params.minimap2.container
        ext.containers = params.minimap2
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            enabled: false
        ]
    }

    withName: SAM_TO_BAM {
        //container = params.samtools.container
        ext.containers = params.samtools
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            enabled: false
        ]
    }

    withName: RACON_POLISH {
        ext.args = ""
        //container = params.racon.container
        ext.containers = params.racon
        // scratch = false
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: {  ["${task.assembly_consensus_directory_name}", "Racon", "Consensus"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.racon.consensus_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.racon.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ]
        ]
    }


    withName: PILON_ITER {
        ext.args = ""
        stageInMode = params.stage_in_mode
        // scratch = false
        ext.containers = params.pilon_iterative
        maxRetries = 3
        errorStrategy = { task.attempt <= task.maxRetries ? sleep(Math.pow(2, task.attempt) * 200 as long) &&  'retry' : 'ignore' }
        publishDir = [
            [
                path: { ["${task.assembly_polishing_directory_name}", "Pilon", "Fasta"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.pilon_iterative.fasta_ext}",
                saveAs: { filename ->
                        filename.equals('versions.yml') ? null : {
                            def tokens = filename.tokenize(".")
                            def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                            def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                            def new_fn = "${new_name}.pilon.${tokens[1..-1].join(".")}"
                            output = parent ? [parent, new_fn].join(File.separator) : new_fn
                        }.call()
                }
            ],
            [
                path: { ["${task.assembly_polishing_directory_name}", "Pilon", "VCF"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.pilon_iterative.vcf_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.pilon.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ],
            [
                path: { ["${task.assembly_polishing_directory_name}", "Pilon", "Changes"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.pilon_iterative.changes_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.pilon.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ],
            [
                path: { ["${task.assembly_polishing_directory_name}", "Pilon", "BAMs"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.pilon_iterative.bam_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.pilon.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]
    }


    withName: MEDAKA_POLISH{
        ext.args = ""
        cache = 'lenient'
        stageInMode = params.stage_in_mode
        // scratch = false
        ext.containers = params.medaka
        maxRetries = 3
        publishDir = [
            [
                path: { ["${task.assembly_polishing_directory_name}", "Medaka"].join(File.separator) },
                mode: params.publish_dir_mode,
                pattern: "*${params.medaka.fasta_ext}",
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.medaka.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]
    }

    withName: BAKTA_DB_DOWNLOAD {
        // scratch = false
        ext.containers = params.bakta
        stageInMode = params.stage_in_mode
    }

    withName: BAKTA_ANNOTATE {
        // scratch = false // bakta uses its own temp dir so things get weird
        errorStrategy = 'ignore' // Some samples do not run through MikroKondo
        ext.containers = params.bakta
        ext.args = params.bakta.args
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_annotations_directory_name}", "Bakta"].join(File.separator) },
                mode: params.publish_dir_mode,
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.bakta.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]

    }

    withName: ABRICATE {
        errorStrategy = 'ignore'
        ext.args = params.abricate.args
        ext.containers = params.abricate
        stageInMode = params.stage_in_mode
        publishDir = [
            [
                path: { ["${task.assembly_annotations_directory_name}", "Abricate"].join(File.separator) },
                mode: params.publish_dir_mode,
                saveAs: { filename ->
                    filename.equals('versions.yml') ? null : {
                        def tokens = filename.tokenize(".")
                        def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                        def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                        def new_fn = "${new_name}.abricate.${tokens[1..-1].join(".")}"
                        output = parent ? [parent, new_fn].join(File.separator) : new_fn
                    }.call()
                }
            ]
        ]
    }

    withName: ECTYPER {
        //container = params.ectyper.container
        ext.containers = params.ectyper
        stageInMode = params.stage_in_mode
        ext.args = params.ectyper.args
        time = '30m'
        // scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "ECTyper"].join(File.separator) },
            mode: params.publish_dir_mode,
            pattern: "*/*",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                    def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.ectyper.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }

    withName: KLEBORATE {
        ext.containers = params.kleborate
        stageInMode = params.stage_in_mode
        // scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "Kleborate"].join(File.separator) },
            mode: params.publish_dir_mode,
            pattern: "*${params.kleborate.txt_ext}",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                    def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.kleborate.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }

    withName: SPATYPER {
        ext.containers = params.spatyper
        stageInMode = params.stage_in_mode
        //scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "SpaTyper"].join(File.separator) },
            mode: params.publish_dir_mode,
            pattern: "*${params.spatyper.tsv_ext}",
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                    def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.spatyper.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }


    withName: SISTR {
        //container = params.sistr.container
        ext.containers = params.sistr
        stageInMode = params.stage_in_mode
        //scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "SISTR"].join(File.separator) },
            mode: params.publish_dir_mode,
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                    def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.sistr.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }

    withName: LISSERO {
        //container = params.lissero.container
        ext.containers = params.lissero
        stageInMode = params.stage_in_mode
        //scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "Lissero"].join(File.separator) },
            mode: params.publish_dir_mode,
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                    def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.lissero.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }

    withName: SHIGEIFINDER {
        ext.containers = params.shigeifinder
        stageInMode = params.stage_in_mode
        scratch = false
        publishDir = [
            path: { ["${task.assembly_subtyping_directory_name}", "ShigeiFinder"].join(File.separator) } ,
            mode: params.publish_dir_mode,
            saveAs: { filename ->
                filename.equals('versions.yml') ? null : {
                    def tokens = filename.tokenize(".")
                    def parent = filename.tokenize(File.separator)[0..<-1].join(File.separator) ?: null
                    def new_name = tokens[0].equals(meta.id) ? meta.id : "${meta.id}.${tokens[0]}"
                    def new_fn = "${new_name}.shigeifinder.${tokens[1..-1].join(".")}"
                    output = parent ? [parent, new_fn].join(File.separator) : new_fn
                }.call()
            }
        ]
    }


    withName: CUSTOM_DUMPSOFTWAREVERSIONS {
        publishDir = [
            path: { "${params.outdir}/pipeline_info" },
            mode: params.publish_dir_mode,
            pattern: '*_versions.yml'
        ]
    }


}
